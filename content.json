{"meta":{"title":"ZYZ BLOG","subtitle":"Action is the proper fruit of knowledge","description":"热爱生活 享受生活 超越生活","author":"ZYZ","url":"https://zyz-1998.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-08-03T03:35:00.000Z","updated":"2019-08-03T05:41:55.174Z","comments":false,"path":"categories/index.html","permalink":"https://zyz-1998.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-03T08:54:47.619Z","updated":"2019-09-03T08:54:47.619Z","comments":false,"path":"about/index.html","permalink":"https://zyz-1998.github.io/about/index.html","excerpt":"","text":"关于我95后，研究生在读懂一些web开发、物联网的知识 座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 爱好热爱运动，尤其篮球、慢跑，另外超级超级喜欢听歌 联系方式QQ：1744020412@qq.com"},{"title":"about","date":"2019-08-03T01:54:20.000Z","updated":"2019-08-03T01:55:09.031Z","comments":true,"path":"about/index-1.html","permalink":"https://zyz-1998.github.io/about/index-1.html","excerpt":"","text":"关于我95后，研究生在读懂一些web开发、物联网的知识，目前主要学习JAVA开发与刷题（leetCode） 座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 爱好热爱运动，尤其篮球、慢跑，另外超级超级喜欢听歌 联系方式QQ：1744020412@qq.com"},{"title":"tags","date":"2019-08-03T03:35:13.000Z","updated":"2019-08-03T05:22:52.772Z","comments":false,"path":"tags/index.html","permalink":"https://zyz-1998.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"List、Set、Map总结","slug":"List,Set,Map总结","date":"2019-08-26T07:41:59.000Z","updated":"2019-09-06T15:28:09.195Z","comments":true,"path":"2019/08/26/List,Set,Map总结/","link":"","permalink":"https://zyz-1998.github.io/2019/08/26/List,Set,Map总结/","excerpt":"首先list与set都继承于Collection( 描述所有集合共性的接口)，list以序列的形式存储元素。所以取出来的顺序可能和放入顺序不同。set的特点是无法存放重复的元素。map特点：一个映射不能包含重复的键；每个键最多只能映射一个值。以键值对存放数据。三者都是接口且不能被实例化。","text":"首先list与set都继承于Collection( 描述所有集合共性的接口)，list以序列的形式存储元素。所以取出来的顺序可能和放入顺序不同。set的特点是无法存放重复的元素。map特点：一个映射不能包含重复的键；每个键最多只能映射一个值。以键值对存放数据。三者都是接口且不能被实例化。 1. List定义：实现了 Collection 接口，实现类：ArrayList 、 LinkedList 和 Vector，ArrayList提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。Vector实现了一个动态数组。 特点：1.可以允许重复的对象。2.可以插入多个null元素。3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。 1.1 ArrayListArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 提供了快速的基于索引的成员访问方式，对尾部成员的增加和删除支持较好。使用 ArrayList 创建的集合，允许对集合中的元素进行快速的随机访问，不过，向 ArrayList 中插入与删除元素的速度相对较慢。该类的常用构造方法有如下两种重载形式。ArrayList()：构造一个初始容量为 10 的空列表。ArrayList(Collection&lt;?extends E&gt;c)：构造一个包含指定 Collection 的元素的列表，这些元素是按照该 Collection 的迭代器返回它们的顺序排列的。 方法 作用 add(int index, Object obj) 增加元素， size() 长度 get() 获取第i个 set() 修改某位置的元素 remove() 可以放下标，也可以放元素;ps:如果删除的元素存在多个，删除第一个； indexOf(), 用来获得指定对象的索引位置，当存在多个时返回第一个的索引位置，否则返回-1 lastIndexOf(Object obj) 用来获得指定对象的索引位置，当存在多个时返回最后一个的索引位置，否则返回-1 addAll(int, Collection coll) 用来向集合的指定索引位置添加指定集合的所有对象 toArray() 入参为一个数组，将list的元素复制到数组中 clear() 清空集合中的所有元素 contains() 判断集合是否包含制定元素 containsAll() 判断集合是否包含制定集合的所有元素，跟顺序无关 isEmpty() 判断集合是否为空size == 0 trimToSize() 将数组还原到当前大小容量 12345678910111213141516171819202122232425262728293031323334353637public class Demo7 &#123; public static void main(String[] args) &#123; // 创建ArrayList ArrayList list = new ArrayList(); // 将“” list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); // 将下面的元素添加到第1个位置 list.add(0, \"5\"); // 获取第1个元素 System.out.println(\"the first element is: \"+ list.get(0)); // 删除“3” list.remove(\"3\"); // 获取ArrayList的大小 System.out.println(\"Arraylist size=: \"+ list.size()); // 判断list中是否包含\"1\" System.out.println(\"ArrayList contains 1 is: \"+ list.contains(\"1\")); // 设置第2个元素为10 list.set(1, \"10\"); // 通过Iterator遍历ArrayList for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; System.out.println(\"next is: \"+ iter.next()); &#125; // 将ArrayList转换为数组 String[] arr = (String[])list.toArray(new String[0]); for (String str:arr) System.out.print(\"str: \"+ str + \" \"); System.out.println(); // 清空ArrayList list.clear(); // 判断ArrayList是否为空 System.out.println(\"ArrayList is empty: \"+ list.isEmpty()); &#125;&#125; 1.2 LinkedList采用链表结构保存对象，这种结构的优点是便于向集合中插入或者删除元素。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高，但是 LinkedList 类随机访问元素的速度则相对较慢。这里的随机访问是指检索集合中特定索引位置的元素。 1.3 Vector实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的： Vector 是同步访问的。 Vector 包含了许多传统的方法，这些方法不属于集合框架。Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 12345678910111213141516171819202122232425262728293031323334353637public class Demo6 &#123; public static void main(String[] args)&#123; Vector v1 = new Vector(); Integer integer1 = new Integer(1); v1.addElement(\"aaa\"); v1.addElement(\"bbb\"); v1.addElement(\"ccc\"); v1.addElement(integer1); v1.addElement(integer1); v1.addElement(\"ddd\"); v1.addElement(new Integer(2)); System.out.println(v1); v1.insertElementAt(\"insert\",2); v1.insertElementAt(new Float(6.5),3); v1.insertElementAt(new String(\"eee\"),3); System.out.println(v1); //从向量对象v1中删除对象integer1 //由于存在多个integer1,所以从头开始。 //找删除找到的第一个integer1. v1.removeElement(integer1); //使用枚举类(Enumeration)的方法取得向量对象的每个元素。 Enumeration enumeration= v1.elements(); System.out.println(\"The vector v1 (used method removeElememt()is\"); while (enumeration.hasMoreElements()) System.out.print(enumeration.nextElement()+\" \"); System.out.println(); //按不同的方向查找对象integer1所处的位置 System.out.println(\"The position of Object1(top-to-botton):\"+v1.indexOf(integer1)); System.out.println(\"The position of Object1(tottom-to-top):\"+v1.lastIndexOf(integer1)); //重新设置v1的大小，多余的元素被抛弃 v1.setSize(4); System.out.println(\"The new Vector(resized the vector)is:\"+v1); &#125;&#125; 2. Set 特点：1.不允许重复对象2.无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。3.只允许一个 null 元素 Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。 2.1 HashSet线程不安全，存取速度快。底层是以哈希表实现的 12345678910111213141516171819202122232425public class Demo &#123; public static void main(String[] args) &#123; // Set 集合存和取的顺序不一致。 Set hs = new HashSet(); hs.add(\"AAAAAAA\"); hs.add(\"BBBBBBB\"); hs.add(\"CCCCCCC\"); hs.add(\"DDDDDDD\"); System.out.println(hs);//[AAAAAAA, CCCCCCC, DDDDDDD, BBBBBBB]，无序 // 返回此 set 中的元素的数量 System.out.println(hs.size()); // 4 // 如果此 set 尚未包含指定元素，则返回 true boolean add = hs.add(\"CCCCCCC\"); // false System.out.println(add); // 返回此 set 中的元素的数量 System.out.println(hs.size());// 4 Iterator it = hs.iterator(); while (it.hasNext()) &#123; System.out.print(it.next()+\" \"); &#125;//AAAAAAA CCCCCCC DDDDDDD BBBBBBB，无序 &#125;&#125; 2.2 HashSet判断元素重复原理通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型。判断两个元素是否相同，先要判断元素的hashCode值是否一致，只有在该值一致的情况下，才会判断equals方法，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。 注意：HashSet集合在判断元素是否相同先判断hashCode方法，如果相同才会判断equals。如果不相同，是不会调用equals方法的。 2.3 TreeSet适用场景：同时要求数据有序且不重复时。ArrayList 、 LinkedList不能去除重复数据。HashSet可以去除重复，但是是无序。 123456789101112public class Demo &#123; public static void main(String[] args) &#123; TreeSet ts = new TreeSet(); ts.add(\"AAAAAAA\"); ts.add(\"CCCCCCC\"); ts.add(\"DDDDDDD\"); ts.add(\"BBBBBBB\"); ts.add(\"BBBBBBB\"); System.out.println(ts); // [AAAAAAA, BBBBBBB, CCCCCCC, DDDDDDD] &#125;&#125; 3 map 1.Map不是collection的子接口或者实现类。Map是一个接口。2.Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。3.TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序。4.Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。 Map 接口最常用的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用） 3.1 HashMap最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null(多条会覆盖);允许多条记录的值为 Null。 hashmap是一个散列表，存储内容为键值对(key: value)的映射形式hashmap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap实例有两个影响其性能的参数:初始容量和oad因子。容量是哈希表中的桶数，初始容量就是创建哈希表时的容量。负载因子是衡量在哈希表的容量被自动增加之前，哈希表被允许获得多少满的度量。当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希(即重新构建内部数据结构)，这样哈希表的桶数大约是桶数的两倍。 3.2 HashMap四种遍历增强for循环keySet(), entrySet(),与迭代器keySet(), entrySet()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Demo3 &#123; public static void main(String[] args) &#123; // 初始化，10W次赋值 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; 100000; i++) map.put(i, i); /** 增强for循环，keySet迭代 **/ long start = System.currentTimeMillis(); for (Integer key : map.keySet()) &#123; map.get(key); &#125; long end = System.currentTimeMillis(); System.out.println(\"增强for循环，keySet迭代 -&gt; \" + (end - start) + \" ms\"); /** 增强for循环，entrySet迭代 */ start = System.currentTimeMillis(); for (Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; entry.getKey(); entry.getValue(); &#125; end = System.currentTimeMillis(); System.out.println(\"增强for循环，entrySet迭代 -&gt; \" + (end - start) + \" ms\"); /** 迭代器，keySet迭代 **/ start = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = map.keySet().iterator(); Integer key; while (iterator.hasNext()) &#123; key = iterator.next(); map.get(key); &#125; end = System.currentTimeMillis(); System.out.println(\"迭代器，keySet迭代 -&gt; \" + (end - start) + \" ms\"); /** 迭代器，entrySet迭代 **/ start = System.currentTimeMillis(); Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator1 = map.entrySet().iterator(); Map.Entry&lt;Integer, Integer&gt; entry; while (iterator1.hasNext()) &#123; entry = iterator1.next(); entry.getKey(); entry.getValue(); &#125; end = System.currentTimeMillis(); System.out.println(\"迭代器，entrySet迭代 -&gt; \" + (end - start) + \" ms\"); &#125;&#125;// 结果// C:\\SoftWare\\Java\\jdk1.8.0_211\\bin\\java.exe// 增强for循环，keySet迭代 -&gt; 7 ms// 增强for循环，entrySet迭代 -&gt; 7 ms// 迭代器，keySet迭代 -&gt; 4 ms// 迭代器，entrySet迭代 -&gt; 3 ms 总结: 增强for循环使用方便，但性能较差，不适合处理超大量级的数据。 迭代器的遍历速度要比增强for循环快很多，是增强for循环的2倍左右。 使用entrySet遍历的速度要比keySet快很多，是keySet的1.5倍左右。 3.3 Hashtable与 HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtale在写入时会比较慢。 12345678910111213141516171819202122232425262728public class Demo2 &#123; public static void main(String args[]) &#123; Hashtable balance = new Hashtable(); Enumeration names; String str; double bal; balance.put(\"Zara\", new Double(1314.00)); balance.put(\"Mahnaz\", new Double(123.22)); balance.put(\"Ayan\", new Double(1378.00)); balance.put(\"Daisy\", new Double(99.22)); balance.put(\"Qadir\", new Double(-19.08)); // 枚举所有变量 names = balance.keys(); while(names.hasMoreElements()) &#123; str = (String) names.nextElement(); System.out.println(str + \": \" + balance.get(str)); &#125; System.out.println(); // 获取Zara的值添加1000后再保存 bal = ((Double)balance.get(\"Zara\")).doubleValue(); balance.put(\"Zara\", new Double(bal+1000)); System.out.println(\"Zara's new balance: \" + balance.get(\"Zara\")); &#125;&#125; 3.4 TreeMapTreeMap用于存储与HashMap类非常相似的键值对。区别在于TreeMap提供了一种以排序顺序存储键/值对的有效方法。它是基于红黑树的NavigableMap实现。能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 1234567891011121314151617181920212223242526272829303132public class Demo1 &#123; public static void main(String[] args) &#123; //Natual ordering by deafult TreeMap&lt;Integer, String&gt; pairs = new TreeMap&lt;&gt;(); pairs.put(2, \"B\"); pairs.put(1, \"A\"); pairs.put(3, \"C\"); String value = pairs.get(3); //get method System.out.println(value); //C value = pairs.getOrDefault(5, \"oops\"); //getOrDefault method System.out.println(value); //oops //Iteration example Iterator&lt;Integer&gt; iterator = pairs.keySet().iterator(); while(iterator.hasNext()) &#123; Integer key = iterator.next(); System.out.println(\"Key: \" + key + \", Value: \" + pairs.get(key)); &#125; //Key: 1, Value: A //Key: 2, Value: B //Key: 3, Value: C //Remove example pairs.remove(3); System.out.println(pairs); //&#123;1=A, 2=B&#125; System.out.println(pairs.containsKey(1)); //containsKey method System.out.println(pairs.containsValue(\"B\")); //containsValue method System.out.println(pairs.ceilingKey(1)); &#125;&#125; 3.5 红黑树红黑树是一棵二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡。 具体性质如下：1.每个节点颜色非黑即红。2.根节点是黑色的3.如果一个节点是红色，那么它的两个子节点就是黑色的（没有连续的红节点）4.对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点 3.6 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历的时候会比HashMap慢。key和value均允许为空，非同步的 1234567891011121314151617181920public class Demo8 &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, Object&gt; hasMap = new LinkedHashMap&lt;String, Object&gt;(); hasMap.put(\"name\", \"zyz\"); hasMap.put(\"age\", 20); hasMap.put(\"address\", \"北京市\"); hasMap.put(null, null); hasMap.put(\"info\", null); hasMap.put(null, \"who\"); for (Map.Entry&lt;String, Object&gt; entry : hasMap.entrySet()) &#123; System.out.println(entry.getKey() + \"=\" + entry.getValue()); &#125; &#125;&#125;//name=zyz//age=20//address=北京市//null=who//info=null","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/tags/Java/"}],"author":"zyz"},{"title":"next配置gittalk评论系统","slug":"next添加gittalk评论系统","date":"2019-08-21T06:50:09.000Z","updated":"2019-08-21T08:38:26.799Z","comments":true,"path":"2019/08/21/next添加gittalk评论系统/","link":"","permalink":"https://zyz-1998.github.io/2019/08/21/next添加gittalk评论系统/","excerpt":"博客一直没有来得及添加评论系统，主要是考虑添加哪一个评论系统。最终选择gittalk，看了许多网上的文章发现都是旧版本的，本文适用next7.3版本。","text":"博客一直没有来得及添加评论系统，主要是考虑添加哪一个评论系统。最终选择gittalk，看了许多网上的文章发现都是旧版本的，本文适用next7.3版本。 Gitalk是利用了GithubAPI，将网站的评论转写到Github上指定仓库的Issues里，相当于做了一个代理. 1. 建立评论仓库建立一个名gitalk-commnet的评论仓库 2. 新建OAuth Appsgithub沿路径setting/Developer setting/OAuth Apps，新建自己的OAuth Apps，并参照下图填写， Register Application后可以看到client_id与client_secret请将其保存留待下步 3. 更改配置文件在主题配置文件next/_config.yml搜索锁定gitalk，并如下更改 12345678910111213gitalk: enable: true github_id: #github用户名,登陆时习惯用邮箱的放这里不行。一定得是自己的ID! id: location.pathname repo: gitalk-commnet #仓库名 client_id: #application的id，即上文client_id client_secret: #application的密码，即上文client_secret admin_user: distraction_free_mode: false # Gitalk's display language depends on user's browser or system environment # If you want everyone visiting your site to see a uniform language, you can set a force language value # Available values: en | es-ES | fr | ru | zh-CN | zh-TW language: zh-CN 4 . 问题解决4.1 未找到相关的issue进行评论，请联系@XXX初始化创建问题： 未找到相关的issue进行评论，请联系@XXX初始化创建浏览器进入开发者模式，我们可以看到https://api.github.com/user 401 (Unauthorized) 解决办法：在主题配置文件中gitalk配置里添加id: location.pathname 更多解决可以参照https://github.com/gitalk/gitalk/issues/138 4.2 自动初始化待解决，不然每次自己一篇篇文章初始化，想想都不能忍。","categories":[{"name":"博客","slug":"博客","permalink":"https://zyz-1998.github.io/categories/博客/"}],"tags":[{"name":"next","slug":"next","permalink":"https://zyz-1998.github.io/tags/next/"},{"name":"gitalk","slug":"gitalk","permalink":"https://zyz-1998.github.io/tags/gitalk/"}],"author":"zyz"},{"title":"SpringBoot-7. 使用Swagger构建API文档","slug":"SpringBoot-7. 使用Swagger构建文档","date":"2019-08-20T08:27:03.000Z","updated":"2019-08-26T07:44:51.904Z","comments":true,"path":"2019/08/20/SpringBoot-7. 使用Swagger构建文档/","link":"","permalink":"https://zyz-1998.github.io/2019/08/20/SpringBoot-7. 使用Swagger构建文档/","excerpt":"swagger可以降低我们前后端开发文档同步问题，其能够根据我们的代码注释自动生成API文档，而我们只需简单的运用其注释即可，可视化的呈现程序所有的接口列表，非常方便我们前后端进行接口调试。","text":"swagger可以降低我们前后端开发文档同步问题，其能够根据我们的代码注释自动生成API文档，而我们只需简单的运用其注释即可，可视化的呈现程序所有的接口列表，非常方便我们前后端进行接口调试。 The Best APIs are Built with Swagger Tools Swagger工具可以帮助我们完成生成和维护API文档的工作，确保我们的文档在API发展过程中保持最新状态。 1. 添加Swagger依赖1234567891011&lt;!-- swagger --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 2. 新建SwaggerConfig类123456789101112131415161718192021@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api()&#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfo( \"Spring Boot Swagger Test\", \"我的博客网站：https://zyz-1998.github.io/，欢迎大家访问。\", \"API V1.0\", \"Terms of service\", new Contact(\"zyz\", \"https://zyz-1998.github.io/\", \"1744020412@qq.com\"), \"Apache\", \"http://www.apache.org/\", Collections.emptyList()); &#125;&#125; 3. 添加文档内容用于Controller(控制类) 注解 作用 @Api 将一个类标记为Swagger资源 @ApiOperation 给API增加说明，描述针对特定路径的操作或通常为HTTP方法 @ApiResponses 描述API操作的响应 @ApiImplicitParams、@ApiImplicitParam 给API参数增加说明。 用于model(实体类) 注解 作用 @ApiModel 注解实体 @ApiModelProperty 定义实体属性 官方注解文档：http://docs.swagger.io/swagger-core/apidocs/index.html 4. 访问验证http://localhost:8080/swagger-ui.html#/ 效果如下：","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://zyz-1998.github.io/tags/Springboot/"},{"name":"Swagger","slug":"Swagger","permalink":"https://zyz-1998.github.io/tags/Swagger/"}],"author":"zyz"},{"title":"SpringBoot-6. blog system填坑版 shiro","slug":"SpringBoot-6 blogsystem填坑版","date":"2019-08-17T05:57:40.000Z","updated":"2019-08-23T08:03:09.073Z","comments":true,"path":"2019/08/17/SpringBoot-6 blogsystem填坑版/","link":"","permalink":"https://zyz-1998.github.io/2019/08/17/SpringBoot-6 blogsystem填坑版/","excerpt":"俗话说光说不练假把式，实习中发现了自己许多不足，特此挖个坑，做个简单的博客系统以便对于web开发有更深的理解，再者为以后做打算，毕竟基于github的博客还是有一定的不便的，博客基于springboot2.1开发，shiro实现权限控制，插件EditorMD。毕竟是填坑版，还有许多功能不完善甚至没有Σ( ° △ °|||)︴","text":"俗话说光说不练假把式，实习中发现了自己许多不足，特此挖个坑，做个简单的博客系统以便对于web开发有更深的理解，再者为以后做打算，毕竟基于github的博客还是有一定的不便的，博客基于springboot2.1开发，shiro实现权限控制，插件EditorMD。毕竟是填坑版，还有许多功能不完善甚至没有Σ( ° △ °|||)︴ 一. 系统简介1.1 开发工具软件：intellij框架：springboot、shiro(安全框架)前端：thymeleaf + bootstrap日志：logback数据库：mysql插件：Editormd(支持markdown) 1.2 效果预览鉴于目前系统距离完善还相差甚远，遂赶紧贴几张图填填坑。鉴于篇幅这里主要介绍shiro配置资源地址：https://github.com/zyz-1998/blog-system 二. shiro简介 Apache shiro是一个功能强大且易于使用的Java安全框架，可执行身份验证，授权，加密和会话管理。 理解shiro首要理解两张图即可，如下所示 2.1 系统架构在shiro架构中，有3个最主要的组件：Subject，SecurityManager，Realm。Subject本质上就是当前访问用户的抽象描述。SecurityManager是Shiro架构中最核心的组件，通过它可以协调其他组件完成用户认证和授权。换句话来说，SecurityManager就是Shiro框架的控制器。Realm定义了访问数据的方式，用来连接不同的数据源，如：LDAP，关系数据库，配置文件等等。 2.2 核心架构 Authenticator(认证)：负责执行用户的登录操作。Authentication Strategy(认证策略)：是个无状态的组件，在认证过程中会进行4次调用。然后将Realm中的结果信息封装至AuthenticationInfo实例中并返回作为Subject的身份信息。Authorizer(授权)：负责用户的访问权限控制。 2.3 具体实现 定义实体用户信息、用户角色、用户权限 12345678910111213//UserInfo@Id @GeneratedValue private Integer uid; @Column(unique =true) private String username;//帐号 private String name;//名称（昵称或者真实姓名，不同系统不同定义） private String password; //密码; private String salt;//加密密码的盐 private byte state;//用户状态,0:创建未认证（比如没有激活，没有输入验证码等等）--等待验证的用户 , 1:正常状态,2：用户被锁定. @ManyToMany(fetch= FetchType.EAGER)//立即从数据库中进行加载数据; @JoinTable(name = \"SysUserRole\", joinColumns = &#123; @JoinColumn(name = \"uid\") &#125;, inverseJoinColumns =&#123;@JoinColumn(name = \"roleId\") &#125;) private List&lt;SysRole&gt; roleList;// 一个用户具有多个角色 12345678910111213141516//SysRole@Id@GeneratedValue private Integer id; // 编号 private String role; // 角色标识程序中判断使用,如\"admin\",这个是唯一的: private String description; // 角色描述,UI界面显示使用 private Boolean available = Boolean.FALSE; // 是否可用,如果不可用将不会添加给用户 //角色 -- 权限关系：多对多关系; @ManyToMany(fetch= FetchType.EAGER) @JoinTable(name=\"SysRolePermission\",joinColumns=&#123;@JoinColumn(name=\"roleId\")&#125;,inverseJoinColumns=&#123;@JoinColumn(name=\"permissionId\")&#125;) private List&lt;SysPermission&gt; permissions; // 用户 - 角色关系定义; @ManyToMany @JoinTable(name=\"SysUserRole\",joinColumns=&#123;@JoinColumn(name=\"roleId\")&#125;,inverseJoinColumns=&#123;@JoinColumn(name=\"uid\")&#125;) private List&lt;UserInfo&gt; userInfos;// 一个角色对应多个用户 12345678910111213//SysPermission@Id@GeneratedValue private Integer id;//主键. private String name;//名称. @Column(columnDefinition=\"enum('menu','button')\") private String resourceType;//资源类型，[menu|button] private String url;//资源路径. private String permission; //权限字符串,menu例子：role:*，button例子：role:create,role:update,role:delete,role:view private Long parentId; //父编号 private String parentIds; //父编号列表 private Boolean available = Boolean.FALSE; @ManyToMany @JoinTable(name=\"SysRolePermission\",joinColumns=&#123;@JoinColumn(name=\"permissionId\")&#125;,inverseJoinColumns=&#123;@JoinColumn(name=\"roleId\")&#125;) 定义Realm，继承AuthorizingRealm重写以下两个方法 123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; System.out.println(\"权限配置--&gt;MyShiroRealm.doGetAuthorizationInfo()\"); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); UserInfo userInfo = (UserInfo)principals.getPrimaryPrincipal(); for(SysRole role:userInfo.getRoleList())&#123; authorizationInfo.addRole(role.getRole()); for(SysPermission p:role.getPermissions())&#123; authorizationInfo.addStringPermission(p.getPermission()); &#125; &#125; return authorizationInfo;&#125;//表示根据用户身份获取授权信息。这种方式的好处是当只需要身份验证时只需要获取身份验证信息而不需要获取授权信息/*主要是用来进行身份认证的，也就是说验证用户输入的账号和密码是否正确。*/@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(\"MyShiroRealm.doGetAuthenticationInfo()\"); //获取用户的输入的账号，getPrincipal()获取自定义Realm信息 String username = (String)token.getPrincipal(); //输出令牌的获取凭证 System.out.println(token.getCredentials()); //通过username从数据库中查找 User对象，如果找到，没找到. //实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 UserInfo userInfo = userInfoService.findByUsername(username); System.out.println(\"-----&gt;&gt;userInfo=\"+userInfo); if(userInfo == null)&#123; return null; &#125; //简单的验证信息 身份验证信息 SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( userInfo, //用户名 userInfo.getPassword(), //密码 ByteSource.Util.bytes(userInfo.getCredentialsSalt()),//salt=username+salt getName() //realm name ); return authenticationInfo;&#125; 最后进行shiro配置，核心代码如下 12345678910111213141516171819202122ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();shiroFilterFactoryBean.setSecurityManager(securityManager);//拦截器.Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String,String&gt;();//配置退出过滤器,其中的具体的退出代码Shiro已经替我们实现了filterChainDefinitionMap.put(\"/logout\", \"logout\");// 配置不会被拦截的链接 顺序判断//filterChainDefinitionMap.put(\"/static/**\", \"anon\");filterChainDefinitionMap.put(\"/image/**\", \"anon\");//imgfilterChainDefinitionMap.put(\"/css/**\", \"anon\");//cssfilterChainDefinitionMap.put(\"/js/**\", \"anon\");//jsfilterChainDefinitionMap.put(\"/home/**\", \"anon\");//front desk//&lt;!-- 过滤链定义，从上向下顺序执行，一般将/**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了;//&lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt;filterChainDefinitionMap.put(\"/**\", \"authc\");// 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面shiroFilterFactoryBean.setLoginUrl(\"/login\");// 登录成功后要跳转的链接shiroFilterFactoryBean.setSuccessUrl(\"/admin\");//未授权界面;shiroFilterFactoryBean.setUnauthorizedUrl(\"/403\");shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://zyz-1998.github.io/tags/Springboot/"},{"name":"Shiro","slug":"Shiro","permalink":"https://zyz-1998.github.io/tags/Shiro/"}],"author":"zyz"},{"title":"SpringBoot-5. logback日志配置","slug":"SpringBoot-5 logback日志配置","date":"2019-08-13T05:57:40.000Z","updated":"2019-08-17T09:32:35.393Z","comments":true,"path":"2019/08/13/SpringBoot-5 logback日志配置/","link":"","permalink":"https://zyz-1998.github.io/2019/08/13/SpringBoot-5 logback日志配置/","excerpt":"SpringBoot内部集成了LogBack日志依赖，SpringBoot默认使用LogBack记录日志信息，默认根据logback-springboot.xml配置内容来输出到控制台和文件之中。","text":"SpringBoot内部集成了LogBack日志依赖，SpringBoot默认使用LogBack记录日志信息，默认根据logback-springboot.xml配置内容来输出到控制台和文件之中。 By default, Spring Boot logs only to the console and does not write log files. If you want to write log files in addition to the console output, you need to set a logging.file or logging.path property (for example, in your application.properties). 通过在配置文件application.properties中设置 logging.path= 或者logging.file=来指定日志输出路径，也可以在xml中设定，如下参考 1. 控制类例子12345678910111213141516171819202122232425262728package com.neo.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import java.util.Map;@Controllerpublic class LoginController &#123; protected static final Logger logger = LoggerFactory.getLogger(LoginController.class); @RequestMapping(\"/login\") public String login(HttpServletRequest request, Map&lt;String, Object&gt; map) throws Exception&#123; logger.info(\"登录控制器，登录\"); // 登录失败从request中获取shiro处理的异常信息。 // shiroLoginFailure:就是shiro异常类的全类名. String exception = (String) request.getAttribute(\"shiroLoginFailure\"); logger.info(\"异常\" + exception); &#125; @RequestMapping(\"/403\") public String unauthorizedRole()&#123; logger.info(\"------没有权限-------\"); return \"403\"; &#125;&#125; LogBack读取配置文件的步骤（1）尝试classpath下查找文件logback-test.xml（2）如果文件不存在，尝试查找logback.xml（3）如果两个文件都不存在，LogBack用BasicConfiguration自动对自己进行最小化配置，这样既实现了上面我们不需要添加任何配置就可以输出到控制台日志信息。 2. logback配置文件resources目录下新建logback配置文件logback.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"false\"&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt; &lt;property name=\"LOG_HOME\" value=\"./logs\" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/runtime.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 效果如下 3. 屏蔽记录日志如果我们在项目中需要屏蔽某个或者多个包下不输出日志也不记录日志到文件内，那么我们需要修改application.yml添加对应配置:logging: level: com.ly.logback.controller: ‘off’ 参考链接：https://www.jianshu.com/p/6dcb2e05dc5a","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://zyz-1998.github.io/tags/Springboot/"}],"author":"zyz"},{"title":"SpringBoot-4. thymeleaf+jpa实现增删改查与登录验证","slug":"SpringBoot-4 thymeleaf+jpa增删改查","date":"2019-08-08T09:32:33.000Z","updated":"2019-08-21T07:59:43.557Z","comments":true,"path":"2019/08/08/SpringBoot-4 thymeleaf+jpa增删改查/","link":"","permalink":"https://zyz-1998.github.io/2019/08/08/SpringBoot-4 thymeleaf+jpa增删改查/","excerpt":"实例主要运用thymeleaf与jpa，实现数据的增删改查的功能，并进一步添加了登录功能（实现拦截器与视图解析的基本配置）jpa为我们提供便捷数据库操作，简化开发难度，thymeleaf实现前端数据渲染。资源地址：https://github.com/zyz-1998/project/tree/master/jpaThymeleafTest","text":"实例主要运用thymeleaf与jpa，实现数据的增删改查的功能，并进一步添加了登录功能（实现拦截器与视图解析的基本配置）jpa为我们提供便捷数据库操作，简化开发难度，thymeleaf实现前端数据渲染。资源地址：https://github.com/zyz-1998/project/tree/master/jpaThymeleafTest 一、实例简介实体类(domain)定义实体，数据访问层(Dao)实现对数据库的操作，数据服务层(Service)定义各种服务接口，数据服务的实现(serviceImpl)定义数据服务层的具体实现，控制层(Controller)响应请求配置信息类(configure)实现诸如拦截器、视图解析的配置。目录结构部分效果 二. Thymeleaf Thymeleaf是服务器端的一种Java模板引擎 优点：静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调 2.1 导入thymeleaf依赖12&lt;dependency&gt; pId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2.2 引入命名空间1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2.3 th属性 功能 标签 功能和jsp对比 1 Fragment inclusion th:insert th:replace include(片段包含) 2 Fragment iteration th:each c:forEach(遍历) 3 Conditional evaluation th:if th:unless th:switch th:case c:if(条件判断) 4 Local variable definition th:object th:with c:set(声明变量) 5 General attribute modification th:attr th:attrprepend th:attrappend 属性修改支持前面和后面追加内容 6 Specific attribute modification th:value th:href th:src … 修改任意属性值 7 Text (tag body modification) th:text th:utext 修改标签体内容utext：不转义字符大标题 8 Fragment specification th:fragment 声明片段 9 Fragment removal th:remove 删除模板片段 2.4 标准表达式语法${...} 变量表达式，Variable Expressions @{...} 链接表达式，Link URL Expressions #{...} 消息表达式，Message Expressions ~{...} 代码块表达式，Fragment Expressions *{...} 选择变量表达式，Selection Variable Expressions 三. jpa Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。 Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现 当我们需要定义自己的Repository的时候，我们可以继承JpaRepository，从而获得Spring为我们预先定义的多种基本数据操作方法。 pom.xml导入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; application.properties配置 1234567891011#jdbcspring.datasource.url=jdbc:mysql://127.0.0.1/test?useUnicode=true&amp;characterEncoding=utf-8&amp;&amp;serverTimezone=UTC&amp;useSSL=truespring.datasource.username=rootspring.datasource.password=zyz98spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#jpaspring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show.sql=true#禁用thymeleaf缓存spring.thymeleaf.cache=false 四. 登录拦截器配置定义LoginHandlerInterceptor类实现HandlerInterceptor接口方法，preHandle()请求处理前执行操作 123456789101112public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user!=null) return true; request.setAttribute(\"loginMsg\",\"没权限请先登录\"); request.getRequestDispatcher(\"/login\").forward(request,response); return false; &#125;&#125; 在configure层MyConfigure类中添加登录拦截器 12345678910111213@Configurationpublic class MyConfigure implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry)&#123; registry.addViewController(\"/\").setViewName(\"/user/login\"); registry.addViewController(\"/login\").setViewName(\"/user/login\"); &#125; //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/\",\"/login\",\"/userLogin\"); &#125;&#125; 参考链接： http://www.ityouknow.com/springboot/2017/09/23/spring-boot-jpa-thymeleaf-curd.html https://www.cnblogs.com/songxingzhu/p/9597927.html","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://zyz-1998.github.io/tags/Springboot/"}],"author":"zyz"},{"title":"next主题初步配置美化","slug":"next主题初步配置美化","date":"2019-08-03T09:32:33.000Z","updated":"2019-08-12T00:23:31.178Z","comments":true,"path":"2019/08/03/next主题初步配置美化/","link":"","permalink":"https://zyz-1998.github.io/2019/08/03/next主题初步配置美化/","excerpt":"最近突然迷上了next主题，故换上这个新装，并初步进行了相关文章、本地搜索、页面点击效果、文章置顶、网页标签图标等设置，算是简单的完成了这次的主题的配置，后期还待优化，毕竟next主题自定义和扩展都很丰富。","text":"最近突然迷上了next主题，故换上这个新装，并初步进行了相关文章、本地搜索、页面点击效果、文章置顶、网页标签图标等设置，算是简单的完成了这次的主题的配置，后期还待优化，毕竟next主题自定义和扩展都很丰富。 1. 添加相关文章功能插件：hexo-related-popular-posts 插件地址：https://github.com/tea3/hexo-related-popular-posts#1-edit-your-theme 安装：npm install hexo-related-popular-posts –save 修改：hexo-theme-next/blob/master/layout/_macro/post.swig文件 修改如下 12345678&lt;/footer&gt; &lt;/div&gt; &#123;&#123; popular_posts( &#123;&#125; , post ) &#125;&#125; &#123;######################&#125; &#123;### END POST BLOCK ###&#125; &#123;######################&#125; &lt;/article&gt; 2. 添加本地搜索功能插件：hexo-generator-search npm install hexo-generator-search --save 在站点配置文件_config.yml添加如下 123456# Search search: path: ./public/search.xml field: post format: html limit: 1000 修改主题配置文件_config.yml如下 12345local_search: enable: true trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 3. 添加页面点击效果修改_layout.swig，并在\\themes\\next\\layout_layout.swig文件末尾添加 1&lt;script type=\"text/javascript\" src=\"/js/clicklove.js\"&gt;&lt;/script&gt; 创建clicklove.js文件并置于/themes/next/source/js目录下 1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 4. 添加文章置顶修改 hero-generator-index 插件，将文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 之后在文章中添加top属性即可，赋值越大排名越高 1234567title: testdate: 2019-08-02 13:45:48tags: - 技巧categories: 技巧copyright: truetop: 100 5. 添加网页标签图标修改主题配置文件 12345favicon: small: /images/favicon.ico medium: /images/favicon.ico apple_touch_icon: /images/favicon.ico safari_pinned_tab: /images/favicon.ico 这里用的都是一张图片，next原配置也是用的一张图片只是格式大小不同，我试过直接设置favicon: /images/favicon.ico 但是会报错。 6. 设置网页加载进度条这里用到的是theme-next-pace地址如下：https://github.com/theme-next/theme-next-pace 123456pace: enable: true # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: flash 7. 设置标签样式修改主题配置文件,这里因为我用的是next最新版本直接设置即可， 12# Use icon instead of the symbol # to indicate the tag at the bottom of the posttag_icon: true 旧版可以通过修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 8. 设置侧边栏修改主题配置文件，搜索social:找到如下位置 123456789101112131415161718social: GitHub: https://github.com/yourname || github E-Mail: https://email.com/yourname || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter Facebook: https://www.facebook.com/ || facebook Cloudmusic: https://music.163.com/#/user/home?id=247843674 || headphones #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true #是否显示图标 icons_only: false #仅显示图标 transition: false 格式如下Cloudmusic: https://music.163.com/#/user/home?id=247843674 || headphones社交连接名称: 社交连接地址 || 社交连接图标注意该图标必须是Font Awesome中的图标名称 9. 关闭目录自动序列1234toc: enable: true # Automatically add list number to toc. number: false #设置为false即可 参考资料 https://xian6ge.cn/posts/5b8c41e7/ https://www.aisun.org/2017/10/hexo-next+dingzhi/ https://blog.csdn.net/nightmare_dimple/article/details/86661502","categories":[{"name":"博客","slug":"博客","permalink":"https://zyz-1998.github.io/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zyz-1998.github.io/tags/hexo/"}],"author":"zyz"},{"title":"SpringBoot-3. 配置视图解析器与拦截器","slug":"SpringBoot-3 配置视图解析器与拦截器","date":"2019-08-01T11:40:54.000Z","updated":"2019-08-10T00:13:39.532Z","comments":true,"path":"2019/08/01/SpringBoot-3 配置视图解析器与拦截器/","link":"","permalink":"https://zyz-1998.github.io/2019/08/01/SpringBoot-3 配置视图解析器与拦截器/","excerpt":"在SpringBoot1.5版本中我们通过继承WebMvcConfigurerAdapter类重写addViewControllers和addInterceptors来实现添加视图解析与拦截配置，而在2.1.6版本中WebMVCConfigurationAdapter会被提示失效，此时我们可以通过实现WebMVCConfigurer接口或继承WebMvcConfigurationSupport类来实现之前的功能。详情如下：","text":"在SpringBoot1.5版本中我们通过继承WebMvcConfigurerAdapter类重写addViewControllers和addInterceptors来实现添加视图解析与拦截配置，而在2.1.6版本中WebMVCConfigurationAdapter会被提示失效，此时我们可以通过实现WebMVCConfigurer接口或继承WebMvcConfigurationSupport类来实现之前的功能。详情如下： 一. 失效的webMvcConfigurerAdapter配置1234567891011121314151617public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"Dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\"). excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter; &#125; 二. 实现WebMvcConfigurer接口1234567891011121314151617//解决代码@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; //设置默认首页 @Override public void addViewControllers(ViewControllerRegistry registry)&#123; registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"success\"); &#125; //拦截器 @Override public void addInterceptors(InterceptorRegistry registry)&#123; registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/index.html\",\"/\",\"/login\"); &#125;&#125; 2.1 WebMVCConfigurer重点方法讲解12345678910111213141516/* 拦截器配置 */void addInterceptors(InterceptorRegistry var1);/* 视图跳转控制器 */void addViewControllers(ViewControllerRegistry registry);/** *静态资源处理 */void addResourceHandlers(ResourceHandlerRegistry registry);/* 默认静态资源处理器 */void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer);/** * 这里配置视图解析器 */void configureViewResolvers(ViewResolverRegistry registry);/* 配置内容裁决的一些选项*/void configureContentNegotiation(ContentNegotiationConfigurer configurer); 三. 实现WebMvcConfigurationSupport 类1234567891011121314151617@Configurationpublic class MyMvcConfig extends WebMvcConfigurationSupport &#123; @Override protected void addViewControllers(ViewControllerRegistry registry)&#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.setOrder(Ordered.HIGHEST_PRECEDENCE); super.addViewControllers(registry); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry)&#123; registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\"); super.addResourceHandlers(registry); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://zyz-1998.github.io/tags/Springboot/"}],"author":"zyz"},{"title":"SpringBoot-2. 数据注入-配置文件","slug":"SpringBoot-2 数据注入-配置文件","date":"2019-07-28T05:39:46.000Z","updated":"2019-08-10T00:13:42.416Z","comments":true,"path":"2019/07/28/SpringBoot-2 数据注入-配置文件/","link":"","permalink":"https://zyz-1998.github.io/2019/07/28/SpringBoot-2 数据注入-配置文件/","excerpt":"配置文件数据注入的流程 1 导入配置文件处理器，pom.xml 添加依赖spring-boot-configuration-processor 2 JavaBean (Person.class Dog.class)定义实体类 3 配置文件 application.yml或application.properties 4 在test(单元测试)运行TestPersonApplicationTests.class观察结果","text":"配置文件数据注入的流程 1 导入配置文件处理器，pom.xml 添加依赖spring-boot-configuration-processor 2 JavaBean (Person.class Dog.class)定义实体类 3 配置文件 application.yml或application.properties 4 在test(单元测试)运行TestPersonApplicationTests.class观察结果 一. 添加依赖新建springboot maven项目并在pom.xml中添加spring-boot-configuration-processor 12345&lt;!-- 导入配置文件处理器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/dependency&gt; 二. 定义实体类12345678910111213141516171819//Person.java@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; private String LastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125;//Dog.javapublic class Dog &#123; private String name; private Integer age;&#125; Map&lt;String,Object&gt;将唯一的键映射到值List&lt;Object&gt;：继承于Collection和一个 List实例存储一个有序集合的元素。Collection接口：允许你使用一组对象，是Collection层次结构的根接口。 2.1 小技巧ALT键+Ins键选择Getter And Setter构建getXXX()和setXXX()方法选择ToString构建toString() 2.2 注解详解@Component 向容器注入对象.@ConfigurationProperties(prefix = “person”)@ConfigurationProperties告诉StringBoot将本类中的所有属性和配置文件中相关的配置进行绑定。prefix = &quot;person&quot; 配置文件中person下的所有属性进行一一映射只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能@Validated 校验信息,可以直接在bean属性上配置,也可以在properties中配置。 2.3 加载不同的配置文件加载默认配置@ConfigurationProperties(prefix = “person”)默认从全局配置文件中获取值，加载指定配置properties文件格式@PropertySource(value={“classpath:person.properties”})@PropertySource 只支持XXX.properties文件，不支持XXX.yml文件。加载指定配置yml文件格式通过PropertySourcePlaceholderConfigurer来加载yml文件，暴露yml文件到spring environment官方文档https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-yaml-shortcomings 123456789// 加载YML格式自定义配置文件 @Bean public static PropertySourcesPlaceholderConfigurer properties() &#123; PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer(); YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean(); yaml.setResources(new FileSystemResource(\"config.yml\"));//File引入 // yaml.setResources(new ClassPathResource(\"youryml.yml\"));//class引入 configurer.setProperties(yaml.getObject()); return configurer; 三. 配置文件配置application.properties与application.yml任意其一即可，两者均是配置文件功能相同 3.1 配置application.properties1234567891011#配置端口server.port=8081 #配置person的值person.LastName=张三person.birth=2019/07/27person.boss=falseperson.maps.k1=v1person.maps.k2=v12person.lists=a,b,cperson.dog.name=dogperson.dog.age=12 3.2 配置application.yml1234567891011121314server: port: 8081person: LastName: 赵明 age: 21 boss: false birth: 2019/07/27 maps: &#123;k1: v1,k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 四. 运行测试在test(单元测试)运行TestPersonApplicationTests.class观察结果文件格式 123456789101112131415/** * SpringBoot单元测试 * 可以在测试期间很方便的类似编码一样进行自动注入等容器的功能 */@RunWith(SpringRunner.class)@SpringBootTestpublic class TestPersonApplicationTests &#123; @Autowired Person person; @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125; 结果如下 12345672019-07-28 14:48:23.405 INFO 19108 --- [ main] c.c.TestPersonApplicationTests : Started TestPersonApplicationTests in 5.158 seconds (JVM running for 7.158)Person&#123;LastName=&apos;张三&apos;, age=21, boss=false, birth=Sat Jul 27 00:00:00 CST 2019, maps=&#123;k1=v1, k2=v2&#125;, lists=[lisi, zhaoliu], dog=Dog&#123;name=&apos;小狗&apos;, age=2&#125;&#125;2019-07-28 14:48:24.049 INFO 19108 --- [ Thread-2] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &apos;applicationTaskExecutor&apos;Process finished with exit code 0 可以看到已经成功了。","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://zyz-1998.github.io/tags/Springboot/"}],"author":"zyz"},{"title":"hexo主题添加页面百分比","slug":"hexo主题添加页面百分比","date":"2019-07-28T00:26:51.000Z","updated":"2019-08-03T13:42:46.442Z","comments":true,"path":"2019/07/28/hexo主题添加页面百分比/","link":"","permalink":"https://zyz-1998.github.io/2019/07/28/hexo主题添加页面百分比/","excerpt":"首先介绍了Ejs模板引擎以及为Node.js构建的CSS语言——Stylus，便于对博客主题文件中布局与样式的理解。在对主题文件结构有所了解后，为博客添加了一个显示页面百分比的小功能，简单记录一下。主题基于hexo官方主题MiHo，地址https://blog.minhow.com/ 感谢Miho的作者。","text":"首先介绍了Ejs模板引擎以及为Node.js构建的CSS语言——Stylus，便于对博客主题文件中布局与样式的理解。在对主题文件结构有所了解后，为博客添加了一个显示页面百分比的小功能，简单记录一下。主题基于hexo官方主题MiHo，地址https://blog.minhow.com/ 感谢Miho的作者。 一. ejs和stylus1.1 ejs EJS是一个高效的JavaScript模板引擎,帮你利用普通的 JavaScript 代码生成 HTML 页面。 ejs项目的开发基于node.js和express框架，这里Miho中的ejs文件中包含的partial函数是旧版express中的，其功能现由新版EJS的include函数实现，例如引入/.views/user/show.ejs文件可用以下命令 1&lt;%- include(&apos;user/show&apos;); %&gt; ejs基本标签如下&lt;% ‘脚本’ 标签，用于流程控制，无输出。&lt;%_ 删除其前面的空格符&lt;%= 输出数据到模板（输出是转义 HTML 标签）&lt;%- 输出非转义的数据到模板&lt;%# 注释标签，不执行、不输出内容&lt;%% 输出字符串 ‘&lt;%’%&gt; 一般结束标签-%&gt; 删除紧随其后的换行符_%&gt; 将结束标签后面的空格符删除 1.2 stylus Expressive, robust, feature-rich CSS language built for nodejs为nodejs构建的富有表现力，功能强大，功能丰富的CSS语言 通俗理解就是为node.js定制的CSS简化版，省去CSS中的花括号、分号等并扩展了语法内函数、@import的用法。官网地址 https://stylus.bootcss.com/ 二. 添加布局沿miho-&gt;layout打开layout.ejs文件，更改如下： 12345678910111213141516&lt;%- partial(&apos;_partial/head&apos;) %&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;%- partial(&apos;_partial/header&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;div class=&quot;outer&quot;&gt; &lt;section id=&quot;main&quot; class=&quot;body-wrap&quot;&gt;&lt;%- body %&gt;&lt;/section&gt; &lt;% if (theme.sidebar &amp;&amp; theme.sidebar !== &apos;bottom&apos;)&#123; %&gt; &lt;%- partial(&apos;_partial/sidebar&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div id=&quot;page_percentage&quot;&gt;&lt;/div&gt; &lt;%- partial(&apos;_partial/footer&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial(&apos;_partial/after-footer&apos;) %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三. 添加样式miho\\source\\css下style.styl添加。附:_variables.styl可以简单定义部分网站样式，应该是Miho作者预留，每个模块都有注释比较友好。 123456#page_percentage position:fixed bottom:7% right:5% line-height: 27px z-index: 12 四. 添加JS 当前页面的高度 = 获取当前窗口顶部至页面顶部的高度 + 当前窗口高度$(document).height() = $(window).scrollTop() + $(window).height() miho\\source\\js下main.js文件添加如下代码 123456789$(document).scroll(function()&#123; var d_h = $(document).height(); var c_h = $(window).height(); var c_t_h = $(window).scrollTop(); var schedule = c_t_h / (d_h-c_h-0.5); var str=Number(schedule*100).toFixed(); str+=\"%\"; $(\"#page_percentage\").text(str); &#125;); 到这里基本就完成了可以部署并浏览效果了。","categories":[{"name":"博客","slug":"博客","permalink":"https://zyz-1998.github.io/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zyz-1998.github.io/tags/hexo/"},{"name":"ejs","slug":"ejs","permalink":"https://zyz-1998.github.io/tags/ejs/"},{"name":"stylus","slug":"stylus","permalink":"https://zyz-1998.github.io/tags/stylus/"}],"author":"zyz"},{"title":"SpringBoot-1. hello word实例","slug":"SpringBoot-1 hello word实例","date":"2019-07-25T01:09:43.000Z","updated":"2019-08-10T00:13:27.107Z","comments":true,"path":"2019/07/25/SpringBoot-1 hello word实例/","link":"","permalink":"https://zyz-1998.github.io/2019/07/25/SpringBoot-1 hello word实例/","excerpt":"开发工具：IntelliJ IDEASping Boot简介：Spring Boot是一个基于Java的开源框架，用于创建微服务、构建独立的生产就绪Spring应用。设计初衷在于简化spring应用的初始搭建与开发过程，通俗理解其不是什么新框架，而是已有框架的整合与配置简化。","text":"开发工具：IntelliJ IDEASping Boot简介：Spring Boot是一个基于Java的开源框架，用于创建微服务、构建独立的生产就绪Spring应用。设计初衷在于简化spring应用的初始搭建与开发过程，通俗理解其不是什么新框架，而是已有框架的整合与配置简化。 一. 准备工作JDK1.8或更高版本项目自动构建工具：Gradle或者Maven，推荐Gradle对比maven有着简洁、灵活、可读性强等特点。开发工具 eclipse或intelij等、个人推荐Intellij 二. 创建springboot应用程序1、打开intellij，首页Create new project; 2、点击spring assistant【如果没有spring assistant选项，请首页点击configure-&gt;Plugins后搜索安装即可】下一步; 3、project properties，这里默认下一步即可随后选择spring web start并下一步填写工程名字，最终完成应用程序创建目录结构如下 三. 创建HelloController.java在src-&gt;main-&gt;java中创建包hello，并在包内创建HelloController.java这里的目的是创建web控制器 12345678910111213141516HelloController.javapackage hello;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.RequestMapping;@RestControllerpublic class HelloController &#123; @RequestMapping(\"/\") public String index() &#123; return \"Greetings from Spring Boot!\"; &#125;&#125; @RestController是spring4之后的新注解，即@Controller和@ResponseBody的组合注解，使Web请求返回数据而不是视图。@RequestMapping配置url映射，即可以作用在控制器的某个方法上，也可以作用在此控制器类上当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上。而处理器方法上的@RequestMapping注解会对类级别以上的@RequestMapping的声明进行补充。@RequestMapping中的method参数有很多中选择，一般使用get/post. 四. 创建Application.javahello包内创建Application.java 1234567891011121314151617181920212223242526272829303132333435Application.javapackage hello;import java.util.Arrays;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) &#123; return args -&gt; &#123; System.out.println(\"Let's inspect the beans provided by Spring Boot:\"); String[] beanNames = ctx.getBeanDefinitionNames(); Arrays.sort(beanNames); for (String beanName : beanNames) &#123; System.out.println(beanName); &#125; &#125;; &#125;&#125; @SpringBootApplication是@Configuration、@EnableAutoConfiguration、@ComponentScan的组合注解(1) @Configuration 是一个类级注释，指示对象是一个bean定义的源。@Configuration 类通过@Bean 注解的公共方法来声明bean(2)@EnableAutoConfiguration 启用 Spring 应用程序上下文的自动配置，试图猜测和配置您可能需要的bean。自动配置类通常采用基于你的classpath 和已经定义的 beans 对象进行应用。被 @EnableAutoConfiguration 注解的类所在的包有特定的意义，并且作为默认配置使用。(3)@ComponentScan为 @Configuration注解的类配置组件扫描指令。同时提供与 Spring XML’s 元素并行的支持。无论是 basePackageClasses()或是 basePackages()（或其 alias 值）都可以定义指定的包进行扫描。如果指定的包没有被定义，则将从声明该注解的类所在的包进行扫描。通俗的讲，@ComponentScan 注解会自动扫描指定包下的全部标有 @Component注解 的类，并注册成bean，当然包括 @Component下的子注解@Service、@Repository、@Controller。@ComponentScan 注解没有类似 、的属性。(4)@Bean 注释是用来表示一个方法实例化，配置和初始化是由 Spring IoC 容器管理的一个新的对象。 五. 运行并访问运行程序后访问http://localhost:8080/效果如下 12345678910 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.6.RELEASE)2019-07-25 10:28:56.845 INFO 2912 --- [ main] hello.Application ....................","categories":[{"name":"Java","slug":"Java","permalink":"https://zyz-1998.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://zyz-1998.github.io/tags/Springboot/"}],"author":"zyz"},{"title":"Bootstrap练手实例","slug":"Bootstrap 练手实例","date":"2019-07-18T11:31:22.000Z","updated":"2019-08-03T06:12:50.164Z","comments":true,"path":"2019/07/18/Bootstrap 练手实例/","link":"","permalink":"https://zyz-1998.github.io/2019/07/18/Bootstrap 练手实例/","excerpt":"因为最近实习涉及前端方面东西还是比较多的，故对相关知识进行下简单的总结，并用bootstrap这个比较流行的框架设计了一个简单的网站，主要页面包括主页、相册、归档、文章等页面，以便对其有更深的理解。资源地址：https://github.com/zyz-1998/project/tree/master/bootstrap_test","text":"因为最近实习涉及前端方面东西还是比较多的，故对相关知识进行下简单的总结，并用bootstrap这个比较流行的框架设计了一个简单的网站，主要页面包括主页、相册、归档、文章等页面，以便对其有更深的理解。资源地址：https://github.com/zyz-1998/project/tree/master/bootstrap_test 部分页面截图 一. HTML5与CSS31.1 html5Html5作为一种标记语言，对于我们进行网页内容结构的划分有着极其重要的帮助，通过最近的实际应用我对它最大的体会就是能够快速架构出一个网站的基本逻辑结构与内容，这一点在html5中推出的一系列语义标签中体现的尤为突出，有着良好结构与命名规范的页面在我们进行构建样式和定义网页行为时理解起来更加容易。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"\"&gt; &lt;head&gt; &lt;meta charset=\"\"&gt; &lt;meta http-equiv=\"\" content=\"\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; #与main的区别，body定义为表示文档内容 &lt;div id=\"container\"&gt; &lt;header&gt; &lt;nav&gt;&lt;/nav&gt; #导航栏，html5规范中不允许将其嵌入address标签中使用 &lt;/header&gt; &lt;main&gt;&lt;/main&gt; #每个页面中只能用一次，用以标记页面主要内容 &lt;aside&gt;&lt;/aside&gt; #侧边栏，具有独立性用以对页面进行补充 &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 除上述内容，还有许多标签，对于这些标签理解其意义与区别十分重要，尤其在兼容性这方面，例如如下区别： 12&lt;div id=&quot;header&quot;&gt; &lt;header&gt;&lt;div id=&quot;footer&quot;&gt; &lt;footer&gt; 前后两者在实际应用中并无太大差别，后者是html5中的新规范，对于我们进行更加清晰的网页布局有着很多帮助，但是也存在着旧浏览器不识别的情况。补充figure标签规定独立的流内容（图像、图表、照片、代码等等），其内容应与主内容有关，但如果被删除，不应对文档流产生影响。article标签定义独立内容section标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分 更多HTML的知识建议访问W3c School浏览文档，便于有更清晰的认识 1.2 css3ccs构建了网页的样式，缤纷多彩的网页就是通过其实现的，就好像盖房子html搭建了整个网页的结构，接下来房子的装饰就交给了css，css3通过模块化，就像装修一样，将网页的装饰分成盒模型、选择器、文本效果、布局等方式，让我们更容易理解和上手。列举几个最近用到的样式 12background-image: linear-gradient(90deg,#f79533 0,#f37055 15%,#ef4e7b 30%,#a166ab 44%,#5073b8 58%,#1098ad 72%,#07b39b 86%,#6dba82 100%) !important;#构建一条线性渐变的背景，由浏览器处理渲染，不像加载图片，加载时间会受到图片大小影响 1.3 居中的几种方法：第一，水平居中：(1)margin:0 auto; (2)通过flex来实现第二，垂直居中：(1)通过盒模型调节margin来实现，(2)通过调节父元素padding;(3)当自己高度和父容器高度未知时, 通过绝对定位： 12parentElement&#123; position:relative; &#125; childElement&#123; position: absolute; top: 50%; transform: translateY(-50%); &#125; (4)父容器只有一个元素且父元素高度已知时，通过相对定位 12parent&#123; height:xxx; &#125; .child&#123; position: relative; top: 50%; transform: translateY(-50%); &#125; (5)还可以用Flex布局： 1parentElement&#123; display:flex; display:-webkit-flex; align-items:center; &#125; 第三，水平垂直居中：通过tansform：translate(-50%,-50%)来实现。 1position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); html内容超出了div或p的宽度如何换行让内容自动换行 12word-wrap：break-word；overflow：hidden 对于css需要充分理解各属性的区别和应用场景。 二. JQueryJQuery是一个JScript函数库，BootStrap是一个基于html、css、JScript的前端框架，移动设备优先原则的响应式设计。并有着众多的UI编辑工具 2.1 JQueryJQuery重点——AJAX异步，能够在不重载整个页面的情况下，加载数据。load()方法从服务器加载数据，并把返回的数据放入被选元素中。 1$(selector).load(URL,data,callback); get()方法通过 HTTP GET 请求从服务器上请求数据。 1$.get(URL,callback); post() 方法通过 HTTP POST 请求从服务器上请求数据。 1$.post(URL,data,callback); 2.2 Jquery显示页面进度在应用中实现了一个简单的显示页面进度功能，实际效果可下载本文顶部资源链接查看主要公式： 当前页面的高度 = 获取当前窗口顶部至页面顶部的高度 + 当前窗口高度$(document).height() = $(window).scrollTop() + $(window).height() 123456789$(document).scroll(function()&#123; var d_h = $(document).height(); #获取当前页面的高度 var c_h = $(window).height(); #获取当前窗口高度 var c_t_h = $(window).scrollTop(); #获取当前窗口顶部至页面顶部的高度 var schedule = c_t_h / (d_h-c_h-0.5); var str=Number(schedule*100).toFixed(); #将小数转换为百分数 str+=\"%\"; $(\"#p_sch\").text(str); &#125;); 三. Bootstrap在实际应用中比较喜欢其样式风格、及网格布局，对于他的UI编辑器工具简单体会下，感觉比较不错，可以通过快速搭建好网站，然后再进行进一步地完善，这里因为我在练习中并没有实际应用，所以不再赘述，bootstrap为我们提供了许多基本组件，诸如下拉菜单、按钮组、导航栏、分页、表单组、进度条等，对于我们应用十分方便。列举部分实际应用的代码轮播，这里我用作头部背景，在相册页面实现，主页头部背景采用background-img的方式实现，通过设置header的padding-bottom百分比的形式与最小高度可以不影响网页的响应式设计，但图片比例有问题时可能会出现拉伸现象。 3.1 轮播1234567891011121314151617181920212223242526272829&lt;div id=\"myCarousel\" class=\"carousel slide\" style=\"width:100%;\"&gt; &lt;!-- 轮播（Carousel）指标 --&gt; &lt;ol class=\"carousel-indicators\"&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"0\" class=\"active\"&gt;&lt;/li&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"1\"&gt;&lt;/li&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"2\"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- 轮播（Carousel）项目 --&gt; &lt;div class=\"carousel-inner\"&gt; &lt;div class=\"item active\"&gt; &lt;a href=\"#\"&gt;&lt;img src=\"images/15.jpg\" alt=\"First slide\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"#\"&gt;&lt;img src=\"images/16.jpg\" alt=\"Second slide\"&gt; &lt;div class=\"carousel-caption sr-only\"&gt;标题&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"#\"&gt;&lt;img src=\"images/17.jpg\" alt=\"Third slide\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 轮播（Carousel）导航 --&gt; &lt;a class=\"left carousel-control\" href=\"#myCarousel\" role=\"button\" data-slide=\"prev\"&gt; &lt;span class=\"sr-only\"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=\"right carousel-control\" href=\"#myCarousel\" role=\"button\" data-slide=\"next\"&gt; &lt;span class=\"sr-only\"&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; 3.2 导航栏123456789101112131415161718192021222324252627282930313233343536373839&lt;nav class=\"navbar navbar-default\" style=\"position:fixed;top: 0;left: 0;width: 100%;opacity:0.8;\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;!-- sr-only Bootstrap的辅助类；代表元素只在屏幕阅读器中显示：sc (screen-reader) --&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;!-- icon-bar 屏幕宽度小于一定程度时，导航栏变为可折叠形式 --&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"Home.html\"&gt;ZYZ&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Test&lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"Home.html\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;&lt;a href=\"Archievs.html\"&gt;Archievs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"Album.html\"&gt;Album&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;About&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;!-- role是html5中的新标签，增加语义性 --&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; 3.3 分页1234567891011121314151617181920第一种：在归档页面有实现&lt;div class=\"col-xs-12 col-sm-12 col-md-12 page11\"&gt; &lt;ul class=\"pagination pagination-lg\"&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; &lt;li &gt;&lt;a href=\"#\" style=\"background-color:#D5D5D5;color:#f79533\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li &gt;&lt;a href=\"#\" style=\"color:#ef4e7b\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li &gt;&lt;a href=\"#\" style=\"color:#5073b8\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li &gt;&lt;a href=\"#\" style=\"color:#1098ad\"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li &gt;&lt;a href=\"#\" style=\"color:#07b39b\"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li &gt;&lt;a href=\"#\"&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;第二种：在page页面有实现&lt;div class=\"col-xs-12 col-sm-12 col-md-12 page11\"&gt; &lt;ul class=\"pager\"&gt; &lt;li class=\"previous\"&gt;&lt;a href=\"#\"&gt;&amp;larr; Previous&lt;/a&gt;&lt;/li&gt; &lt;li class=\"next\"&gt;&lt;a href=\"#\"&gt;Next &amp;rarr;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://zyz-1998.github.io/categories/前端/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://zyz-1998.github.io/tags/bootstrap/"}],"author":"zyz"},{"title":"hexo+github 博客搭建历程","slug":"hexo+github博客搭建","date":"2019-07-17T03:37:43.000Z","updated":"2019-08-03T13:42:23.108Z","comments":true,"path":"2019/07/17/hexo+github博客搭建/","link":"","permalink":"https://zyz-1998.github.io/2019/07/17/hexo+github博客搭建/","excerpt":"详细的将自己搭建博客的过程记录了下，主要是出于两方面考虑：第一，希望能够对同样打算建博客的朋友有所帮助。第二，为自己写博客立起点，让自己养成写博客的习惯，将平日学到的进行总结，避免遗忘。","text":"详细的将自己搭建博客的过程记录了下，主要是出于两方面考虑：第一，希望能够对同样打算建博客的朋友有所帮助。第二，为自己写博客立起点，让自己养成写博客的习惯，将平日学到的进行总结，避免遗忘。 一. 准备工作1）node.js 安装下载地址：https://nodejs.org/en/download2) git 安装下载地址：https://git-scm.com/download3) github注册并建立一个名为123.github.io的仓库，123为你的github账户名 二. git配置该步骤主要目的：将git和github连接起来，便于今后博客的上传部署等操作。 2.1 设置账户和邮箱12$ git config --global user.name \"your name\"$ git config --global user.email \"your email\" 2.2 生成并获取ssh秘钥git bash 输入命令： 1ssh-keygen -t rsa -C \"***@gmail.com\" ***@gmail.com为你注册github时的邮箱，接下来可能需要你输入windows账户的密码，取决于你的账户操作权限,输入密码后一直回车即可。 2.3 配置github ssh将上一步生成的秘钥添加至github中，首先复制秘钥，id_rsa.pub文件中，位置如下供参考 1C:\\Users\\元天墨染\\.ssh\\id_rsa.pub 登录github账户，选择Personal settings &gt; SSH and GPG keys，添加秘钥 2.4 验证链接12$ ssh -T git@github.comHi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 三. hexo安装配置3.1 安装首先建立一个hexo文件夹作为安装目录，git bash【在hexo文件夹也就是你的安装位置打开】输入下列命令 123456npm install hexo-cli -g //安装hexohexo init blog //hexo初始化于blog文件夹cd blognpm install //安装相关依赖包hexo server //本地启动hexo【用作博客发布前本地预览】npm install hexo-deployer-git --save //使用git方式进行部署博客所需插件 3.2 配置_config.yml 站点配置文件package.json 主要描述hexo版本信息及安装的依赖打开_config.yml文件找到deploy并参照下方进行修改 12345deploy: type: git //repo: 应为你的github仓库ssh clone,注意repo:后的空格不能省略 repo: git@github.com:zyz-1998/zyz-1998.github.io.git branch: master 3.3 部署hexo根目录blog打开git bash输入下列命令 1hexo g -d 此时就可以在浏览器输入https://123.github.io/打开hexo默认界面。 四. hexo更换主题访问hexo官网：https://hexo.io/zh-cn/ 在主题页面有许多主题，这里我选择的是mihomiho地址：https://blog.minhow.com/里面有详细的操作流程，这里就不再赘述。 五. 常用命令总结123456hexo new \"我的博客\" //新建文章,在blog\\source\\_posts会生成对应的md文件hexo new page \"pageName\" //新建页面，blog\\source中生成相应的pageName文件夹hexo g == hexo generate //生成静态网页hexo s == hexo server //启动服务预览hexo d == hexo deploy //开始部署以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 //设置文章摘要","categories":[{"name":"博客","slug":"博客","permalink":"https://zyz-1998.github.io/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zyz-1998.github.io/tags/hexo/"}],"author":"zyz"}]}